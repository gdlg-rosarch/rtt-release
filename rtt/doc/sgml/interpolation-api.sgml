<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN"
	"docbook/dtd/4.1/docbook.dtd" [
<!ENTITY orocos "<acronym>Orocos</acronym>">
]>

<article>

<articleinfo>
  <title>
   Interpolation API
  </title>
  <author>
    <firstname>Herman</firstname>
    <surname>Bruyninckx</surname>
    <affiliation>
      <address>
        Herman.Bruyninckx(at)mech.kuleuven.ac.be
      </address>
    </affiliation>
  </author>
 <copyright>
  <year>2003&ndash;2004</year>
  <holder>Herman Bruyninckx &mdash;
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU General Public License
(<ulink
 url="http://www.fsf.org/copyleft/gpl.html">http://www.fsf.org/copyleft/gpl.html</ulink>), 
where the <emphasis>source code</emphasis> of the document is the 
<ulink url="interpolation-api.xml">XML file</ulink>.
  </holder>
 </copyright>

 <abstract>
 <para>
 <emphasis role="strong">Abstract</emphasis>
 </para>
 <para>
This document describes the <emphasis>algorithms</emphasis> and the
<ulink url="deep-shallow-api.html">application programming interface</ulink>
(&ldquo;API&rdquo;) for 
<emphasis role="strong">motion interpolation</emphasis>.
A motion interpolator gets its input from the
<ulink url="motion-api.html">motion generator</ulink>, in the form of
a <emphasis>start point</emphasis>
&ldquo;<emphasis>A</emphasis>&rdquo; and a <emphasis>final
point</emphasis> &ldquo;<emphasis>B</emphasis>&rdquo; which are
&ldquo;far apart&rdquo;, and it
calculates a sequence of intermediate &ldquo;closely separated&rdquo;
setpoints with a granularity that matches the timing of the motion
controller.
 </para>
<!-- link with ViaPoint from motion-api! -->
 </abstract>

 <revhistory>
  <revision>
   <revnumber>0.01</revnumber>
   <date>April 14, 2004</date>
   <authorinitials>HB</authorinitials>
  </revision>
 </revhistory>

</articleinfo>

<section id="motion-interpolation-class">
<title>Interpolation class</title>
<para>
This Section describes some families of 
<link linkend="motion-interpolation">motion interpolators</link>, and
their generic <link linkend="motion-interpolation-api">API</link>. 
As explained before, an interpolator takes as inputs a 
<ulink url="motion-api.html#VIA-POINT">via-point</ulink>, or a
<ulink url="motion-api.html#PATH">path</ulink>, and generates as output
a list of <emphasis role="strong">setpoints</emphasis>, at a much
higher granularity than the input via-points.
</para>
<para>
Motion interpolators are used in the following typical applications:
<itemizedlist>

<listitem>
<para>
<emphasis role="strong">On-line setpoint generator.</emphasis>
Most often, such an interpolator works at the same
frequency as the controller, or at an integer multiple of it.
</para>
</listitem>

<listitem>
<para>
<emphasis role="strong">Off-line motion simulation.</emphasis>
In this application mode, the <emphasis>time resolution</emphasis> of
the generated interpolation points is often less important than the
<emphasis>spatial resolution</emphasis>, especially if the simulator
is interested in finding out the exact geometry traced by the motion.
</para>
</listitem>

</itemizedlist>
The various types of interpolators described above require different
APIs and implementations.
</para>


<section id="motion-interpolation">
<title>Motion interpolators</title>

<para>
The variety of algorithms is caused by the variety of devices and
motion details:
<itemizedlist>

<listitem>
<para>
The via-points and/or setpoints contain only position information, or
also higher derivatives.
</para>
</listitem>

<listitem>
<para>
The setpoints are specified as 1D trajectories (e.g., for each
actuated joint separately), or as higher-dimensional trajectories
(e.g., for a vector of actuated joints that have to move in a
synchronized way; or for a Cartesian interpolation, where there is
most often a geometric coupling between the various degrees of freedom).
</para>
</listitem>

<listitem>
<para>
The setpoints have constant or non-constant spacing, in time and/or
in position.
</para>
</listitem>

<listitem>
<para>
The setpoints are to be generated in a periodic way.
</para>
</listitem>

</itemizedlist>
The following sub-sections describe some of the most popular motion
interpolators.

<section id="trapezoidal-velocity">
<title>
 <parameter>TrapezoidalVelocity</parameter>,
 <parameter>SingleSCurve</parameter>
</title>

<para>
This is a 1D &ldquo;point-to-point&rdquo; interpolator. It generates a
motion from the current state (given position, zero velocity, zero
acceleration) to a desired position, which must be reached with zero
velocity and acceleration. Both velocity and acceleration have maximum
constraints, that should not be exceeded during the motion.
</para>
<para>
The motion profile has different phases, generated by acceleration
pulses (<xref linkend="fig-trap-vel">):
<orderedlist numeration="lowerroman">

<listitem>
<para>
Maximum acceleration pulse, i.e., linearly growing velocity, accelerating
at the specified maximum. This phase takes until the time instant t1
in <xref linkend="fig-trap-vel">.
</para>
</listitem>

<listitem>
<para>
Constant velocity, i.e., zero acceleration. This phase runs between
time instants t1 and t2 in <xref linkend="fig-trap-vel">.
</para>
</listitem>
                                                                                
<listitem>
<para>
Maximum deceleration pulse, between time instant t2 till the end of
the motion at time instant t3.
</para>
</listitem>
                                                                                
</orderedlist>
The name of the interpolator comes from the facts that: (i) the
resulting <emphasis>position</emphasis> profile looks like an
&ldquo;S&rdquo;; (ii) the <emphasis>velocity</emphasis>
profile consists of a trapezoid; and (iii) the acceleration profile
consists of square-wave pulses.  The motion time is determined by the
specified acceleration and velocity constraints.
</para>
<para>
The name <emphasis>SingleSCurve</emphasis> is less constraining than
the name <emphasis>TrapezoidalVelocity</emphasis>, because the idea of
using pulses to generate a motion is more general than the case to
which it is applied here; for example,
<xref linkend="trapezoidal-acceleration-to-velocity"> applies jerk
pulses to interpolate between two desired velocities.
</para>
<para>
<figure id="fig-trap-vel" float="1" pgwide="0">
<title>
Trapezoidal velocity interpolation to reach a given position.
(The position is plotted at one-tenth of the scale.)
</title>
<mediaobject>
<imageobject>
 <imagedata align="center" fileref="../pictures/trapvel.png" format="PNG">
</imageobject>
<imageobject>
 <imagedata align="center" fileref="../pictures/trapvel.eps" format="EPS">
</imageobject>
</mediaobject>
</figure>
</para>
<para>
The mathematics of this motion are as depicted in
<xref linkend="fig-acceleration-integrations">. These follow
straightforwardly from the integration of the acceleration pulses.
Note that the initial velocity v<subscript>0</subscript> and acceleration
a<subscript>0</subscript> are zero in the currently discussed
interpolator.
</para>
<para>
<figure id="fig-acceleration-integrations" float="1" pgwide="0">
<title>
Formulas for the integration of acceleration pulses, with a magnitude
of a<subscript>m</subscript> and a sign &sigma;.
</title>
<mediaobject>
<imageobject>
 <imagedata align="center"
            fileref="../pictures/acceleration-integrations.png"
            format="PNG">
</imageobject>
<imageobject>
 <imagedata align="center"
            fileref="../pictures/acceleration-integrations.eps"
            format="EPS">
</imageobject>
<textobject>
 <phrase>
<![CDATA[
\thispagestyle{empty}
\begin{displaymath}
\begin{aligned}
a(t) = \phantom{\frac{1}{2}}&a_m\ \sigma
      \left\{
  I_0(t-t_0) - I_0(t-t_1) - I_0(t-t_2) + I_0(t-t3)
      \right\}
\\
\\
v(t) = \phantom{\frac{1}{2}}&a_m\ \sigma
      \left\{
  I_0(t-t_0) - I_0(t-t_1) - I_0(t-t_2) + I_0(t-t3)
      \right\}
\\
  &+ v_0
\\
\\
p(t) = \frac{1}{2} &a_m \ \sigma
      \left\{
  I_0(t-t_0) - I_0(t-t_1) - I_0(t-t_2) + I_0(t-t3)
      \right\}
\\
  &+ v_0 (t-t_0) + p_0
\\
\\
p_0 = p(t&=t_0), \quad
v_0 = v(t=t_0), \quad
a_0 = a(t=t_0)
\\
\\
I_y(x) &=
  \begin{cases}
  x^y, \quad x > 0 \\
  0, \quad x \le 0
  \end{cases}
\end{aligned}
\end{displaymath}
]]>
 </phrase>
</textobject>
</mediaobject>
</figure>
</para>
<para>
Often, the distance between start and end position is too small, in
order for the motion to reach its maximum velocity. The interpolator
then skips the zero acceleration phase (i.e., t2 = t1), and reduces
the acceleration time (i.e., t1 gets smaller, and the maximally
reached velocity gets smaller, see the right-hand side
of <xref linkend="fig-acceleration-integrations">).
Alternatively, the maximum acceleration could be reduced; which means
that the motion will take longer, but will require less energy, be
safer, and introduce less vibrations and noise.
</para>
<para>
<xref linkend="trapvel-code"> shows the 
<ulink url="http://www.octave.org">Octave</ulink> code with which
the plots in <xref linkend="fig-trap-vel"> were generated. Only the
initial position conditions differ between both plots; for the
&ldquo;short&rdquo; motion at the right-hand side of
<xref linkend="fig-acceleration-integrations">, the maximum
acceleration was maintained, but the acceleration/deceleration times
are reduced.
The presented code is not a direct implementation of the equations in
<xref linkend="fig-acceleration-integrations">, but somewhat optimized
for execution speed. (Later Sections give more direct, flexible
implementations.)
</para>
<para>
<example id="trapvel-code">
<title>Octave code for trapezoidal velocity interpolation.
</title>
<programlisting>
<![CDATA[
p0 = 20;   p3 = 30;
vm = 3;    am = 1;

t1 = vm / am;
sigma = sign( p3 - p0 );
deltax1 = sigma * am *  t1 * t1 / 2.0;
deltaT = ( p3 - p0 - 2.0 * deltax1 ) / ( sigma * vm );

if ( deltaT > 1.0 )
    duration = 2 * t1 + deltaT;
    t2 = duration - t1;
else
    t1 = sqrt( ( p3 - p0 ) / sigma / am );
    duration = t1 * 2.0;
    t2 = t1;
endif

time=[0:0.01:duration];
[nr, nc] = size(time);
p = zeros(nr,nc); v = zeros(nr,nc); a = zeros(nr,nc);
                                                                                
a3 = sigma * am / 2.0;
a2 = 0;
a1 = p0;
                                                                                
b3 = 0;
b2 = a2 + 2 * a3 * t1 - 2.0 * b3 * t1;
b1 = a1 + t1 * ( a2 + a3 * t1 ) - t1 * ( b2 + t1 * b3 );
                                                                                
c3 = -sigma * am / 2.0;
c2 = b2 + 2 * b3 * t2 - 2.0 * c3 * t2;
c1 = b1 + t2 * ( b2 + b3 * t2 ) - t2 * ( c2 + t2 * c3 );
                                                                                
for t=1:nc
  if ( time(t) < 0 )
    p(t) = p0;
    v(t) = 0;
    a(t) = 0;
  elseif ( time(t) < t1 )
    p(t) = a1 + time(t) * ( a2 + a3 * time(t));
    v(t) = a2 + 2 * a3 * time(t);
    a(t) = 2 * a3;
  elseif ( time(t) < t2 )
    p(t) = b1 + time(t) * ( b2 + b3 * time(t));
    v(t) = b2 + 2 * b3 * time(t);
    a(t) = 2 * b3;
  elseif ( time(t) <= duration )
    p(t) = c1 + time(t) * ( c2 + c3 * time(t) );
    v(t) = c2 + 2 * c3 * time(t);
    a(t) = 2 * c3;
  else
    p(t) = p3;
    v(t) = 0;
    a(t) = 0;
  endif
endfor
]]>
</programlisting>
</example>
</para>
<para>
This <emphasis>SingleSCurve</emphasis> interpolator is quite popular,
because it offers a good trade-off between: 
<itemizedlist>

<listitem>
<para>
<emphasis>Computational complexity</emphasis>: the algorithm can be
calculated analytically, and in short constant time.
</para>
</listitem>

<listitem>
<para>
<emphasis>Time-optimality</emphasis>: the motion uses the specified
maximum velocity and/or acceleration as long as possible.
</para>
</listitem>

<listitem>
<para>
<emphasis>Flexibility</emphasis>: the &ldquo;pulse integration&rdquo;
mathematics of <xref linkend="fig-acceleration-integrations">
are the basis for many interpolators, as illustrated in the following
Sections. 
</para>
</listitem>

<listitem>
<para>
<emphasis>Smoothness</emphasis>: the acceleration of the motion is
continuous.
</para>
</listitem>

</itemizedlist>
</para>

</section>


<section id="trapezoidal-acceleration-to-velocity">
<title><parameter>TrapezoidalAccelerationToVelocity</parameter></title>

<para>
This 1D interpolator generates a motion from the
current state (position, velocity, acceleration) to a desired
velocity, which must be reached with zero acceleration. The position
at that moment, as well as the duration of the motion, result from the
interpolation algorithm, and are not required as input parameters.
</para>
<para>
So, the interpolator's <emphasis role="strong">inputs</emphasis> are:
desired end velocity; initial position; initial velocity; and initial
acceleration.  The <emphasis role="strong">properties</emphasis> are:
maximum velocity, maximum acceleration, and maximum jerk. 
The initial acceleration should not exceed the maximum acceleration.
</para>
<para>
In fact, the mathematics of this interpolator is very similar to
the <link linkend="trapezoidal-velocity">trapezoidal velocity</link>
interpolator to reach a given <emphasis>position</emphasis>: just
replace position by velocity, velocity by acceleration, and
acceleration by jerk. The interpolation in this Section has one extra
complexity: the initial conditions of velocity and acceleration are
not zero, while the <parameter>SingleSCurve</parameter> of
<xref linkend="trapezoidal-velocity"> works with all zero initial
conditions.
</para>
<para>
<anchor id="trap-acc-phases">
The interpolated motion profile has
<emphasis role="strong">three different phases</emphasis>,
corresponding to &ldquo;jerk pulses&rdquo;
(<xref linkend="fig-trap-acc-to-velocity">):
<orderedlist numeration="lowerroman">

<listitem>
<para>
Maximum jerk pulse, i.e., linearly growing acceleration until maximum
acceleration.
</para>
</listitem>

<listitem>
<para>
Zero jerk, i.e., constant acceleration at maximum acceleration, or,
equivalently, linearly growing velocity.
</para>
</listitem>

<listitem>
<para>
Maximum jerk pulse, i.e., linearly decreasing acceleration, until zero
acceleration.
</para>
</listitem>

</orderedlist>
The magnitude of the jerk pulse determines the slope of the
acceleration profile. The maximum acceleration determines the width of
the jerk pulse, as well as the (maximum) slope of the velocity
profile.
<xref linkend="fig-trap-acc-to-velocity"> shows a typical motion
profile generated in this way.
</para>
<para>
<figure id="fig-trap-acc-to-velocity" float="1" pgwide="0">
<title>
Trapezoidal acceleration interpolation to reach a given velocity.
(The position is plotted at one-tenth of the scale.)
</title>
<mediaobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_vel.png" format="PNG">
</imageobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_vel.eps" format="EPS">
</imageobject>
</mediaobject>
</figure>
</para>
<para>
So, the mathematics are a simple extension of
<xref linkend="fig-acceleration-integrations">, as shown in
<xref linkend="fig-jerk-integrations-vel">.
</para>
<para>
<figure id="fig-jerk-integrations-vel" float="1" pgwide="0">
<title>
Formulas for the integration of jerk pulses, with a magnitude
of j<subscript>m</subscript> and a sign &sigma;.
</title>
<mediaobject>
<imageobject>
 <imagedata align="center"
            fileref="../pictures/jerk-integrations-vel.png"
            format="PNG">
</imageobject>
<imageobject>
 <imagedata align="center"
            fileref="../pictures/jerk-integrations-vel.eps"
            format="EPS">
</imageobject>
<textobject>
 <phrase>
<![CDATA[
\begin{displaymath}
\begin{aligned}
j(t) = \phantom{\frac{1}{2}}&j_m\ \sigma
      \left\{
  I_0(t-t_0) - I_0(t-t_1) - I_0(t-t_2) + I_0(t-t_3)
      \right\}
\\
\\
a(t) = \phantom{\frac{1}{2}}&j_m\ \sigma
      \left\{
  I_1(t-t_0) - I_1(t-t_1) - I_1(t-t_2) + I_1(t-t_3)
      \right\}
\\
  &+ a_0
\\
\\
v(t) = \frac{1}{2} &j_m\ \sigma
      \left\{
  I_2(t-t_0) - I_2(t-t_1) - I_2(t-t_2) + I_2(t-t_3)
      \right\}
\\
  &+ a_0 (t-t_0) + v_0
\\
\\
p(t) = \frac{1}{6} &j_m\ \sigma
      \left\{
  I_3(t-t_0) - I_3(t-t_1) - I_3(t-t_2) + I_3(t-t_3)
      \right\}
 \\
 &+ \frac{1}{2} a_0 (t-t_0)^2 + v_0 (t-t_0) + p_0
\\
\\
p_0 = p(t&=t_0), \quad
v_0 = v(t=t_0), \quad
a_0 = a(t=t_0)
\\
\\
I_y(x) &=
  \begin{cases}
  x^y, \quad x > 0 \\
  0, \quad x \le 0
  \end{cases}
\end{aligned}
\end{displaymath}
]]>
 </phrase>
</textobject>
</mediaobject>
</figure>
</para>
<para>
<xref linkend="fig-trap-acc-to-velocity"> is produced with the
following (<ulink url="http://www.octave.org">Octave</ulink>) code,
which is a direct implementation of the code in
<xref linkend="fig-jerk-integrations-vel">:
<programlisting>
<![CDATA[
%% input arguments:
startpos = -10;   startvel = -1;   startacc = 0.8;   endvel = 12;

%% interpolator property values:
maxvel = 3;       maxacc = 2;      maxjrk = 1;
                                                                                
%% find out whether we must accelerate or decelerate:
tmp1 = startacc/maxjrk;
deltavel = endvel - startvel;
direction = sign ( deltavel + sign(startacc) * startacc * tmp1 /2);
                                                                                
%% magnitude of first jerk pulse:
startjrk = direction * maxjrk;

%% time of maximum deceleration phase:
deltatime3 = maxacc / maxjrk;

%% time of maximum acceleration phase:
deltatime1 = deltatime3 - direction * tmp1;

%% time of zero acceleration phase:
deltatime2 = (direction * deltavel + tmp1 * startacc / 2) / maxacc - deltatime3;                                                                                
if (deltatime2 < 0) %% maximum acceleration not reached
  deltatime3 = sqrt( (direction * deltavel + tmp1 * startacc / 2)/maxjrk );
  deltatime1 = deltatime3 - direction * tmp1;
  deltatime2 = 0;
endif

%% time instant when maximum acceleration is reached:
time1 = deltatime1;
%% time instant when maximum acceleration phase ends:
time2 = time1 + deltatime2;
%% time instant when acceleration reaches zero, and end velocity is %reached:
time3 = time2 + deltatime3;

t = [0:0.01:time3+1]; %% we calculate one time instant longer than motion
[nr,nc] = size(t);
jrk = zeros(nr,nc); acc = zeros(nr,nc); vel = zeros(nr,nc); pos = zeros(nr,nc);
                                                                                
for i = 1:nc
  time = t(i);
  if (time < 0)
    error("time instant must be positive");
  elseif (time < time1)
    jrk(i) = startjrk;
    acc(i) = startjrk * time + startacc;
    vel(i) = startjrk * time**2 / 2 + startacc * time + startvel;
    pos(i) = startjrk * time**3 / 6 + startacc * time**2/2 + startvel * time + startpos;
  elseif (time < time2)
    jrk(i) = 0;
    tt1 = time -time1;
    acc(i) = startjrk * (time - tt1) + startacc;
    vel(i) = startjrk * (time**2 - tt1**2)/ 2 + startacc * time + startvel;
    pos(i) = startjrk * (time**3 - tt1**3) / 6 + startacc * time**2/2 + startvel * time + startpos;
  elseif (time < time3)
    tt1 = time -time1;
    tt2 = time -time2;
    jrk(i) = -startjrk;
    acc(i) = startjrk * (time - tt1 - tt2) + startacc;
    vel(i) = startjrk * (time**2 - tt1**2 - tt2**2)/ 2 + startacc * time + startvel;
    pos(i) = startjrk * (time**3 - tt1**3 - tt2**3)/ 6 + startacc * time**2/2 + startvel * time + startpos;
  else
    tt1 = time -time1;
    tt2 = time -time2;
    tt3 = time -time3;
    jrk(i) = 0;
    acc(i) = 0;
    vel(i) = endvel;
    pos(i) =  startjrk * (time**3 - tt1**3 - tt2**3 + tt3**3)/ 6 + startacc * time**2/2 + startvel * time + startpos;
  endif
endfor
]]>
</programlisting>
</para>
<para>
For &ldquo;short&rdquo; motions, the interpolator might not reach the
constant acceleration phase, or, in other words, it doesn't reach the
maximum velocity.
</para>

</section>


<section id="trapezoidal-acceleration-to-position">
<title>
 <parameter>TrapezoidalAccelerationToPosition</parameter>, 
 <parameter>DoubleSCurve</parameter>
</title>

<para>
This interpolator is an extension of the
<link linkend="trapezoidal-acceleration-to-velocity">TrapezoidalAccelerationToVelocity</link>
interpolator.  It generates a motion from the current state (position,
velocity, acceleration) to a desired <emphasis>position</emphasis>,
which must be reached with zero velocity and acceleration.  The
duration of the motion results from the maximum velocity, acceleration
and jerk constraints in the interpolation algorithm, and is not
required as input parameter.
</para>
<para>
So, the <emphasis role="strong">inputs</emphasis> are:
desired end position; initial position; initial velocity; and initial
acceleration. The <emphasis role="strong">properties</emphasis> are:
maximum velocity, maximum acceleration, and maximum jerk. The initial
acceleration should not exceed the maximum acceleration.
</para>
<para>
Roughly speaking, a
<parameter>TrapezoidalAccelerationToPosition</parameter> motion
consists of two
<parameter>TrapezoidalAccelerationToVelocity</parameter> motions glued
together by a constant velocity motion
(<xref linkend="fig-trap-acc-to-position">):
<itemizedlist>

<listitem>
<para>
Moving from the current velocity to the specified maximum velocity.
This is the first &ldquo;trapezoid&rdquo; in the motion.
</para>
</listitem>

<listitem>
<para>
The time-reversal of the motion from zero velocity to the specified
maximum velocity. This is the second &ldquo;trapezoid&rdquo; in the
motion.
</para>
</listitem>

</itemizedlist>
However, both trapezoids still have to be &ldquo;glued&rdquo;
together; and that is not always straightforward.
</para>
<para>
<figure id="fig-trap-acc-to-position" float="1" pgwide="0">
<title>
Acceleration and jerk profiles.
</title>
<mediaobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_pos.png" format="PNG">
</imageobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_pos.eps" format="EPS">
</imageobject>
</mediaobject>
</figure>
</para>
<para>
The motion profile has the same three initial phases as
<link linkend="trapezoidal-acceleration-to-velocity">TrapezoidalAccelerationToVelocity</link>,
resulting in a motion towards maximum velocity, at time instant t3.
Then the motion has the following four phases, determined by jerk
pulses:
<orderedlist numeration="lowerroman" continuation="continues">

<listitem>
<para>
Zero jerk, i.e., zero acceleration, and constant (maximum)
     velocity, between times t3 and t4.
</para>
</listitem>

</orderedlist>
Then, the last three phases are a time-reversed trapezoid of a
<parameter>TrapezoidalAccelerationToVelocity</parameter> motion:
<orderedlist numeration="lowerroman" continuation="continues">

<listitem>
<para>
Maximum jerk pulse, i.e., constantly changing acceleration, between
times t4 and t5.
</para>
</listitem>

<listitem>
<para>
Zero jerk, i.e., zero acceleration between times t5 and t6.
</para>
</listitem>

<listitem>
<para>
Maximum jerk pulse, i.e., constantly changing acceleration, between
times t6 and t7.
</para>
</listitem>

</orderedlist>
As said already, the last three phases are mirrors of the 
<link linkend="trap-acc-phases">first three phases</link>, except for
the fact that the t6-t7 phase moves until zero velocity and
acceleration, while the t0-t1 phase starts from non-zero velocity
and acceleration.
</para>
<para>
So, the resulting <emphasis>velocity</emphasis> profile looks like a
double, mirrored &ldquo;S&rdquo;, and the
<emphasis>acceleration</emphasis> profile consists of two mirrored
trapezoids.
</para>
<para>
Mathematically speaking,
the profile is the result of the integration of the jerk pulses,
and the mathematics shown in
<xref linkend="fig-jerk-integrations-pos"> are an extension of the
formulas in <xref linkend="fig-acceleration-integrations"> and
<xref linkend="fig-jerk-integrations-vel">.
</para>

<para>
<figure id="fig-jerk-integrations-pos" float="1" pgwide="0">
<title>
Analytical expressions for the jerk, acceleration, velocity and
position curves.
</title>
<mediaobject>
<imageobject>
<imagedata fileref="../pictures/jerk-integrations-pos.png" format="PNG">
</imageobject>
<imageobject>
<imagedata fileref="../pictures/jerk-integrations-pos.eps" format="EPS">
</imageobject>
</mediaobject>
</figure>
</para>

<para>
<figure id="fig-trapacc-pos-plot" float="1" pgwide="0">
<title>
Plots for the jerk, acceleration, velocity and position, for a nominal
motion.
</title>
<mediaobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_pos-plot.png" format="PNG">
</imageobject>
<imageobject>
<imagedata fileref="../pictures/trapacc_pos-plot.eps" format="EPS">
</imageobject>
</mediaobject>
</figure>
</para>
<para>
<xref linkend="fig-trapacc-pos-plot"> is produced with the
following (<ulink url="http://www.octave.org">Octave</ulink>) code:
<programlisting>
<![CDATA[
% initial position, velocity and acceleration:
p0 = 30; v0 = -2; a0 = -1;

% initial time:
t0 = 0;

% the profile has seven distinct phases, ending at time t7.
% final position and velocity:
p7 = 100;
v7 = 0; % currently always zero!

% (Absolute values of) maximum velocity, acceleration and jerk:
vm = 7; am = 2; jm = 1;

%% algorithm:
%% Step 1: choose direction of first and third jerk pulses:
sign1 = 1;
sign2 = -1;

j0 = sign1 * jm;
j4 = sign2 * jm;

% t1 is reached from t0 by maximum acceleration from a0 till am:
deltat1 = (am-a0)/jm;
t1 = t0 + deltat1;

% time needed between t2 and t3 (= maximum deceleration from am till
% zero):
deltat3 = am/jm;

% the velocity increase in this deltat3 equals the velocity increase
% (from zero) during the time interval 0-deltat3. 
deltav3 = 0.5*jm*deltat3*deltat3;

% the velocity reaches its maximum vm at t3, hence:
v2 = vm - deltav3;

% filling in v(t=t2)=v2 gives:
t2 = (v2+a0*t0-v0+0.5*j0*deltat1*(t1+t0))/(j0*deltat1+a0);
t3 = t2 + deltat3;

% the time interval deltat between t4 and t7 equals:
deltat56 = (vm/jm-deltat3*deltat3)/deltat3;
deltat = 2*deltat3 + deltat56;

% in that time interval, the motion reaches vm, hence 
% v(t=t4) = vm. In that period, a distance p47 is covered:
% p47 = p(t=deltat,a0=0,v0=0,p0=0):
p47 = jm/6*(deltat**3-(deltat-deltat3)**3-deltat3**3);

% during the period until t3, the motion covers a distance
% p03 = p(t=t3,a0=a0,vo=vo,p0=s0):
p03 = j0/6*( (t3-t0)**3 - (t3-t1)**3 - (t3-t2)**3) + 0.5*a0*(t3-t0)**2 + v0*(t3-t0);

% the period of constant maximum velocity vm takes from t3 till t4,
% hence:
t4 = t3 + (p7-p0-p03-p47)/vm;

% TODO: the motion is "too short" if t4 < t3. The code to cope with
% this case is not here yet!

t5 = t4 + deltat3;
t6 = t5 + deltat56
t7 = t6 + deltat3;

t = [0:0.01:t7];
[nr,nc] = size(t);
jrk = zeros(nr,nc);
acc = zeros(nr,nc);
vel = zeros(nr,nc);
pos = zeros(nr,nc);

for i = 1:nc
  time = t(i);
  if (time < t0)
    error("time instant must be positive");
  elseif (time < t1)
    jrk(i) = j0;
    acc(i) = j0 * time + a0;
    vel(i) = j0 * time**2 / 2 + a0 * time + v0;
    pos(i) = j0 * time**3 / 6 + a0 * time**2/2 + v0 * time + p0;
  elseif (time < t2)
    jrk(i) = 0;
    tt1 = time -t1;
    acc(i) = j0 * (time - tt1) + a0;
    vel(i) = j0 * (time**2 - tt1**2)/ 2 + a0 * time + v0;
    pos(i) = j0 * (time**3 - tt1**3) / 6 + a0 * time**2/2 + v0 * time + p0;
  elseif (time < t3)
    tt1 = time -t1;
    tt2 = time -t2;
    jrk(i) = -j0;
    acc(i) = j0 * (time - tt1 - tt2) + a0;
    vel(i) = j0 * (time**2 - tt1**2 - tt2**2)/ 2 + a0 * time + v0;
    pos(i) = j0 * (time**3 - tt1**3 - tt2**3)/ 6 + a0 * time**2/2 + v0 * time + p0;
  elseif (time < t4)
    tt1 = time -t1;
    tt2 = time -t2;
    tt3 = time -t3;
    jrk(i) = 0;
    acc(i) = j0 * (time - tt1 - tt2 + tt3) + a0;
    vel(i) = j0 * (time**2 - tt1**2 - tt2**2 + tt3**2)/ 2 + a0 * time + v0;
    pos(i) = j0 * (time**3 - tt1**3 - tt2**3 + tt3**3)/ 6 + a0 * time**2/2 + v0 * time + p0;
    % index at time = t4:
    t4i = i;
elseif (time < t5)
    tt1 = time -t4;
    jrk(i) = j4;
    acc(i) = acc(t4i) + j4 * tt1;
    vel(i) = vel(t4i) + j4 * tt1**2 /2;
    pos(i) = pos(t4i) + j4 * tt1**3 /6 + vel(t4i)*tt1;
elseif (time < t6)
    tt1 = time -t4;
    tt2 = time -t5;
    jrk(i) = 0;
    acc(i) = acc(t4i) + j4 * (tt1 - tt2);
    vel(i) = vel(t4i) + j4 * (tt1**2 - tt2**2)/2;
    pos(i) = pos(t4i) + j4 * (tt1**3 - tt2**3)/6 + vel(t4i)*tt1;
elseif (time < t7)
    tt1 = time -t4;
    tt2 = time -t5;
    tt3 = time -t6;
    jrk(i) = -j4;
    acc(i) = acc(t4i) + j4 * (tt1 - tt2 - tt3);
    vel(i) = vel(t4i) + j4 * (tt1**2 - tt2**2 - tt3**2)/2;
    pos(i) = pos(t4i) + j4 * (tt1**3 - tt2**3 - tt3**3)/6 + vel(t4i)*tt1;
else
    jrk(i) = 0;
    acc(i) = 0;
    vel(i) = v7;
    pos(i) = p7;
  endif
endfor
]]>
</programlisting>
</para>
<para>
This example shows a <emphasis>nominal</emphasis> motion, i.e., one in
which the maximum velocity and acceleration are reached. However,
one or both of these constraints are not reached in
&ldquo;short&rdquo; motions.
This requires extensions to the code, bringing a significant increase
in complexity:
<itemizedlist>

<listitem>
<para>
It is not straightforward to know in advance whether one must
accelerate or decelerate in both parts of the motion (i.e., time
intervals t0-t3, and t4-t7). Therefore, the
formulas in <xref linkend="fig-jerk-integrations-pos"> have 
<emphasis role="strong">two</emphasis>
&sigma;1 and &sigma;2 variables (being either +1 or -1), depending on
whether the first and third jerk pulses are positive or negative,
respectively.
</para>
</listitem>

<listitem>
<para>
The durations of the nominal t0-t3 and t4-t7 parts of the motion are
calculated as follows (see
<xref linkend="fig-trap-acc-to-position"> and
<xref linkend="fig-jerk-integrations-pos">):
  <itemizedlist>

  <listitem>
  <para>
<emphasis>t1</emphasis>: this is the time instant at which the
acceleration reaches its maximum value. This can be found from filling
in t=t1 in <xref linkend="fig-jerk-integrations-pos">, which leads to
a <emphasis>linear</emphasis> equation in t1.
</para>
<para>
Note that there are
<emphasis role="strong">two alternatives</emphasis> for t1,
depending on the sign &sigma;<subscript>1</subscript>. 
and on the initial acceleration a<subscript>0</subscript>.
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t2</emphasis>: knowing t1, the time instant t2 is found from
the velocity equation in <xref linkend="fig-jerk-integrations-pos">:
the velocity reaches its maximum at t=t2.
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t3</emphasis>: 
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t4</emphasis>: 
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t5</emphasis>: 
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t6</emphasis>: 
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>t7</emphasis>: 
  </para>
  </listitem>

  </itemizedlist>
</para>
</listitem>
                                                                                
<listitem>
<para>
So, one can find out whether the motion is &ldquo;long
enough&rdquo; to indeed reach the maximum velocity. If that is not
the case, however, shrinking the motion is not so straightforward:
  <itemizedlist>

  <listitem>
  <para>
<emphasis>Reduce the maximum velocity.</emphasis> 
The profile of <xref linkend="fig-trap-acc-to-position"> has
zero-acceleration phases t1-t2, t3-t4 and t5-t6, because it wants to
reach maximum velocity. If the resulting motion is too long, even when
these zero-acceleration phases are reduced to zero length,
the acceleration and deceleration phases should be made shorter; i.e.,
the time intervals t0-t1, t2-t3, t4-t5 and t6-t7.
In order to keep the time-optimality of the profile, the maximum jerk
is kept, such that the slope of the acceleration changes remains the
same; one just doesn't move until the maximum acceleration is reached.
  </para>
  <para>
TODO: explain <emphasis>how</emphasis> to scale the maximum velocity.
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>Reduce the maximum acceleration.</emphasis> 
  </para>
  <para>
TODO: explain <emphasis>how</emphasis> to scale the maximum
acceleration.
  </para>
  </listitem>

  <listitem>
  <para>
<emphasis>Reduce the maximum jerk.</emphasis>
  </para>
  <para>
TODO: explain <emphasis>how</emphasis> to scale the maximum jerk.
  </para>
  </listitem>

  </itemizedlist>
</para>
</listitem>

</itemizedlist>
</para>
</section>


<section id="spline-motion">
<title><parameter>SplineMotion</parameter></title>

<para>
The setpoints belong to a spline that interpolates the given
via-points. Of course, there exists a large variety of possible
interpolating splines, not only within one given family of splines,
but also because of the large number of possible spline families.
</para>

</section>


<section id="quaternion-line">
<title>
 <parameter>QuaternionLine</parameter>, 
 <parameter>&hellip;</parameter>
</title> 

<para>
The tool's origin moves along a straight Cartesian line between the
origins of the input via-points, and its orientation is determined by
the linear interpolation of the quaternion vectors corresponding to
the via-points' orientations.
</para>
<para>
This motion interpolation is one of the many with a
linear translational motion and some form of angular interpolation
with a fixed axis in space. This orientation interpolation can often
generate very counter-intuitive motions.
</para>

</section>


<section id="reeds-shepp">
<title>
 <parameter>ReedsShepp</parameter>,
 <parameter>&hellip;</parameter>
</title>

<para>
This is a 2D interpolator. It connects two points in a plane with a
sequence of straight lines and circular arcs.
</para>

</section>


</section>


<section id="motion-interpolation-api">
<title>API</title>

<para>
This Section describes the method calls for motion interpolators. 
The API assumes a <emphasis role="strong">stateful</emphasis>
interpolator object: each of the calls changes some but not
necessarily all parameters of a <emphasis>running</emphasis> interpolator.
So, the interpolator works with absolute time.
</para>
<para>
<variablelist>

 <varlistentry>
 <term>
<anchor id="motion-set-max-velocity">
<function>SetMaxVelocity</function>,
<function>SetMaxAcceleration</function>, and
<function>SetMaxJerk</function>:
 </term>
  <listitem>
   <para>
Set the constraints on the maximum values of the motion parameters.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
 <term>
<anchor id="motion-set-min-velocity">
<function>SetMinVelocity</function>, 
<function>SetMinAcceleration</function> and
<function>SetMinJerk</function>:
 </term>
  <listitem>
   <para>
Set the constraints on the minimum, if the constraints are not
symmetric around zero.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
 <term>
<anchor id="motion-set-goal-position">
<function>SetGoalPosition</function>,
<function>SetGoalVelocity</function>, and
<function>SetGoalAcceleration</function>:
 </term>
  <listitem>
   <para>
Give new inputs to the interpolator.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
 <term>
<anchor id="motion-scale-velocity">
<function>ScaleVelocity</function>,
<function>ScaleAcceleration</function>.
<function>ResetVelocity</function>,
<function>ResetAcceleration</function>.
 </term>
  <listitem>
   <para>
The input argument of the <function>Scale&hellip;</function> methods
is a scalar smaller than 1, which reduces the velocity or acceleration
constraint. 
The <function>Reset&hellip;</function> methods reset the constraints
to their nominal values.
   </para>
   <para>
All these methods can be called at any instant during an ongoing
motion.
   </para>
  </listitem>
 </varlistentry>

 <varlistentry>
 <term>
<anchor id="motion-get-new-setpoint">
<function>GetNewSetpoint</function>:
 </term>
  <listitem>
   <para>
Get a new interpolation point. This method requires a time instant as
input argument. The output can be position, velocity and/or
acceleration, depending on the order of the interpolator.
   </para>
  </listitem>
 </varlistentry>

</variablelist>
It is also useful to have a <emphasis>simulation mode</emphasis> for
the interpolator, i.e., one method call would produce a vector of
setpoints, calculated at given time intervals, and covering the
complete motion. This simulation method call does not need a stateful
object.
</para>

</section>


</section> 

</article>

